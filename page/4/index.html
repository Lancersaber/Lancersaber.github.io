<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Lancersaber">
<meta property="og:url" content="https:&#x2F;&#x2F;lancersaber.github.io&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="Lancersaber">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lancersaber.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Lancersaber</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lancersaber</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/Spring/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0springboot%E4%B8%AD%E7%9A%84SpringApplication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/Spring/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0springboot%E4%B8%AD%E7%9A%84SpringApplication/" class="post-title-link" itemprop="url">深入学习Springboot中的SpringApplication</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-04 10:52:19 / Modified: 20:18:26" itemprop="dateCreated datePublished" datetime="2019-11-04T10:52:19+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入学习Springboot中的SpringApplication"><a href="#深入学习Springboot中的SpringApplication" class="headerlink" title="深入学习Springboot中的SpringApplication"></a>深入学习Springboot中的SpringApplication</h1><hr>
<p>在Spring Boot的入口类中，我们通常是通过调用SpringApplication的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。</p>
<h2 id="自定义Springboot-Application"><a href="#自定义Springboot-Application" class="headerlink" title="自定义Springboot Application"></a>自定义Springboot Application</h2><p>默认的我们都是直接通过SpringApplication的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。</p>
<h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，artifactId为SpringApplication，并引入spring-boot-starter-web依赖。<br>我们将入口类的代码改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = new SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">application.setAdditionalProfiles(&quot;dev&quot;);</span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure>
<p>通过调用SpringApplication的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，SpringApplication还包含了许多别的方法，具体可以查看源码或者官方文档：<br><img src="https://i.loli.net/2019/11/04/UXtg3GvHKd9a8Ar.png" alt="QQ截图20190223101959.png"></p>
<h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p>SpringApplicationBuilder提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(&quot;dev&quot;)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p>SpringApplication的生命周期阶段大致可以分为准备阶段和运行阶段。</p>
<p>我们通过源码来查看SpringApplication的有参构造器：<br><img src="https://i.loli.net/2019/11/04/lnBQ2OJhU3Am5KN.png" alt="QQ截图20190223102806.png"><br>通过有参构造器里的代码我们可以将SpringApplication的准备阶段分为以下几个步骤：</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));这行代码用于加载我们配置的Spring Boot Bean源。。通常我们使用SpringApplication或者SpringApplicationBuilder的构造器来直接指定源。</p>
<p>所谓的Spring Boot Bean源指的是某个被@SpringBootApplication注解标注的类，比如入口类：</p>
<p><img src="https://i.loli.net/2019/11/04/alymOoqibSn1Dkj.png" alt="QQ截图20190223104742.png"></p>
<p>我们也可以将上面的代码改为下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SpringBootApplication</span><br><span class="line">    public static class ApplicationResource &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也是可行的。查看SpringApplication的单个参数构造器：<br><img src="https://i.loli.net/2019/11/04/XkeFJrHvYgV19DW.png" alt="QQ截图20190223105200.png"><br>说明我们除了配置单个源外，还可以配置多个源。</p>
<h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行this.webApplicationType = WebApplicationType.deduceFromClasspath();代码用于推断当前Spring Boot应用类型。<br>Spring Boot 2.0后，应用可以分为下面三种类型：<br>1、WebApplicationType.NONE：非WEB类型；</p>
<p>2、WebApplicationType.REACTIVE：Web Reactive类型；</p>
<p>3、WebApplicationType.SERVLET：Web Servlet类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/Spring/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/Spring/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/" class="post-title-link" itemprop="url">深入学习Spring组件注册</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-04 09:58:12" itemprop="dateCreated datePublished" datetime="2019-11-04T09:58:12+08:00">2019-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-06 21:48:01" itemprop="dateModified" datetime="2019-11-06T21:48:01+08:00">2019-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入学习Spring组件注册"><a href="#深入学习Spring组件注册" class="headerlink" title="深入学习Spring组件注册"></a>深入学习Spring组件注册</h1><hr>
<p>接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动地显示创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。</p>
<p>这里主要记录组件注册的一些细节。</p>
<h2 id="通过-Bean注册组件"><a href="#通过-Bean注册组件" class="headerlink" title="通过@Bean注册组件"></a>通过@Bean注册组件</h2><p>在较早版本的Spring中，我们都是通过XML的方式来往IOC容器中注册组件的，下面这段代码大家肯定不会陌生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 返回 IOC 容器，基于 XML配置，传入配置文件的位置</span><br><span class="line">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);</span><br><span class="line">User user = (User) applicationContext.getBean(&quot;user&quot;);</span><br></pre></td></tr></table></figure>

<p>Spring 4后推荐我们使用Java Config的方式来注册组件。</p>
<p>为了演示，我们通过<a href="http://start.spring.io/搭建一个简单Spring" target="_blank" rel="noopener">http://start.spring.io/搭建一个简单Spring</a> Boot应用，然后引入Lombok依赖（编辑器也需要安装Lombok插件）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>lombok注解解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor:增加全参构造器</span><br><span class="line">@NoArgsConstructor ：增加无参构造器</span><br><span class="line"></span><br><span class="line">@ToString:增加toString方法</span><br><span class="line">@Getter：增加get方法</span><br><span class="line">@Setter：增加set方法</span><br><span class="line">@Data:@ToString,@EqualsAndHashCode,@Getter and @Setter的集合</span><br></pre></td></tr></table></figure>

<p>然后创建一个User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ToString</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建一个配置类，在里面通过@Bean注解注册User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">    @Bean()</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User(&quot;mrbird&quot;, 18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过@Bean注解，我们向IOC容器注册了一个名称为user（Bean名称默认为方法名，我们也可以通过@Bean(“myUser”)方式来将组件名称指定为myUser）。<br>组件注册完毕后，我们测试一下从IOC容器中获取这个组件。在Spring Boot入口类中编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 返回 IOC 容器，使用注解配置，传入配置类</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        User user = context.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们是通过注解方式来注册组件的，所以需要使用AnnotationConfigApplicationContext来获取相应的IOC容器，入参为配置类。</p>
<p>启动项目，看下控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=mrbird, age=18)</span><br></pre></td></tr></table></figure>

<h2 id="使用-ComponentScan扫描"><a href="#使用-ComponentScan扫描" class="headerlink" title="使用@ComponentScan扫描"></a>使用@ComponentScan扫描</h2><p>在使用XML配置组件扫描的时候，我们都是这样配置的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>其中base-package指定了扫描的路径。路径下所有被@Controller、@Service、@Repository和@Component注解标注的类都会被纳入IOC容器中。</p>
<p>现在我们脱离XML配置后，可以使用@ComponentScan注解来扫描组件并注册。</p>
<p>在使用@ComponentScan扫描之前，我们先创建一个Controller，一个Service，一个Dao，并标注上相应的注解。</p>
<p>然后修改配置类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;cc.mrbird.demo&quot;)</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">    // @Bean(&quot;myUser&quot;)</span><br><span class="line">    // public User user() &#123;</span><br><span class="line">    //     return new User(&quot;mrbird&quot;, 18);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中，我们通过@ComponentScan(“cc.mrbird.demo”)配置了扫描路径，并且将User组件注册注释掉了，取而代之的是在User类上加上@Component注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ToString</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips:值得注意的是，我们不能将Spring Boot的入口类纳入扫描范围中，否则项目启动将出错。<br>接下来我们看下在基于注解的IOC容器中是否包含了这些组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        // 查看基于注解的 IOC容器中所有组件名称</span><br><span class="line">        String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(beanNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，观察控制台：<br><img src="https://i.loli.net/2019/11/06/843mfaP5ljxdpbD.png" alt="QQ截图20181207164418.png"><br>可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。</p>
<p>这里，配置类WebConfig也被扫描并注册了，查看@Configuration源码就会发现原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定扫描策略"><a href="#指定扫描策略" class="headerlink" title="指定扫描策略"></a>指定扫描策略</h3><p>@ComponentScan注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Specifies which types are eligible for component scanning.</span><br><span class="line"> * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;@link #basePackages&#125;</span><br><span class="line"> * to everything in the base packages that matches the given filter or filters.</span><br><span class="line"> * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified.</span><br><span class="line"> * Any type under the specified base packages which matches a given filter will be included,</span><br><span class="line"> * even if it does not match the default filters (i.e. is not annotated with &#123;@code @Component&#125;).</span><br><span class="line"> * @see #resourcePattern()</span><br><span class="line"> * @see #useDefaultFilters()</span><br><span class="line"> */</span><br><span class="line">Filter[] includeFilters() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Specifies which types are not eligible for component scanning.</span><br><span class="line"> * @see #resourcePattern</span><br><span class="line"> */</span><br><span class="line">Filter[] excludeFilters() default &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>其中Filter也是一个注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Declares the type filter to be used as an &#123;@linkplain ComponentScan#includeFilters</span><br><span class="line"> * include filter&#125; or &#123;@linkplain ComponentScan#excludeFilters exclude filter&#125;.</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;&#125;)</span><br><span class="line">@interface Filter &#123;</span><br><span class="line"></span><br><span class="line">    FilterType type() default FilterType.ANNOTATION;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;classes&quot;)</span><br><span class="line">    Class&lt;?&gt;[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    Class&lt;?&gt;[] classes() default &#123;&#125;;</span><br><span class="line">    String[] pattern() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用excludeFilters来排除一些组件的扫描：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(value = &quot;cc.mrbird.demo&quot;,</span><br><span class="line">        excludeFilters = &#123;</span><br><span class="line">                @Filter(type = FilterType.ANNOTATION,</span><br><span class="line">                        classes = &#123;Controller.class, Repository.class&#125;),</span><br><span class="line">                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)</span><br><span class="line">        &#125;)</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们指定了两种排除扫描的规则：<br>1、根据注解来排除（type = FilterType.ANNOTATION）,这些注解的类型为classes = {Controller.class, Repository.class}。即Controller和Repository注解标注的类不再被纳入到IOC容器中。</p>
<p>2、根据指定类型类排除（type = FilterType.ASSIGNABLE_TYPE），排除类型为User.class，其子类，实现类都会被排除。</p>
<p>启动项目，观察控制台：<br><img src="https://i.loli.net/2019/11/06/tZnzrAiHm1Rj3dk.png" alt="QQ截图20190129103606.png"></p>
<p>除了上面两种常用的规则外，我们还可以使用别的规则，查看FilterType源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum FilterType &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Filter candidates marked with a given annotation.</span><br><span class="line">     *</span><br><span class="line">     * @see org.springframework.core.type.filter.AnnotationTypeFilter</span><br><span class="line">     */</span><br><span class="line">    ANNOTATION,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Filter candidates assignable to a given type.</span><br><span class="line">     *</span><br><span class="line">     * @see org.springframework.core.type.filter.AssignableTypeFilter</span><br><span class="line">     */</span><br><span class="line">    ASSIGNABLE_TYPE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Filter candidates matching a given AspectJ type pattern expression.</span><br><span class="line">     *</span><br><span class="line">     * @see org.springframework.core.type.filter.AspectJTypeFilter</span><br><span class="line">     */</span><br><span class="line">    ASPECTJ,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Filter candidates matching a given regex pattern.</span><br><span class="line">     *</span><br><span class="line">     * @see org.springframework.core.type.filter.RegexPatternTypeFilter</span><br><span class="line">     */</span><br><span class="line">    REGEX,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Filter candidates using a given custom</span><br><span class="line">     * &#123;@link org.springframework.core.type.filter.TypeFilter&#125; implementation.</span><br><span class="line">     */</span><br><span class="line">    CUSTOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多扫描策略配置"><a href="#多扫描策略配置" class="headerlink" title="多扫描策略配置"></a>多扫描策略配置</h3><p>在Java 8之前，我们可以使用@ComponentScans来配置多个@ComponentScan以实现多扫描规则配置：<br><img src="https://i.loli.net/2019/11/06/jLfierT5y86NqMS.png" alt="QQ截图20190129100809.png"><br>而在Java 8中，新增了@Repeatable注解，使用该注解修饰的注解可以重复使用，查看@ComponentScan源码会发现其已经被该注解标注：<br><img src="https://i.loli.net/2019/11/06/QkHAMz6gZPo8Rhb.png" alt="QQ截图20190129101050.png"><br>所以除了使用@ComponentScans来配置多扫描规则外，我们还可以通过多次使用@ComponentScan来指定多个不同的扫描规则。</p>
<h3 id="自定义策略配置"><a href="#自定义策略配置" class="headerlink" title="自定义策略配置"></a>自定义策略配置</h3><h2 id="组件作用域-Scope"><a href="#组件作用域-Scope" class="headerlink" title="组件作用域@Scope"></a>组件作用域@Scope</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个，我们来看下例子。</p>
<p>首先将User对象中的@Component注解去除，然后在配置类中配置User Bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User(&quot;mrbird&quot;, 18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着多次从IOC容器中获取这个组件，看看是否为同一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 返回 IOC 容器，使用注解配置，传入配置类</span><br><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">Object user1 = context.getBean(&quot;user&quot;);</span><br><span class="line">Object user2 = context.getBean(&quot;user&quot;);</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>

<p>启动项目，观察控制台输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>结果证实了上面的观点。</p>
<p>在Spring中我们可以使用@Scope注解来改变组件的作用域：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/Spring/%E6%B7%B1%E5%85%A5Spring%20boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/Spring/%E6%B7%B1%E5%85%A5Spring%20boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" class="post-title-link" itemprop="url">深入Spring boot自动装配</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-04 08:33:38 / Modified: 11:08:19" itemprop="dateCreated datePublished" datetime="2019-11-04T08:33:38+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入Spring-boot自动装配"><a href="#深入Spring-boot自动装配" class="headerlink" title="深入Spring boot自动装配"></a>深入Spring boot自动装配</h1><hr>
<h2 id="模式注解"><a href="#模式注解" class="headerlink" title="模式注解"></a>模式注解</h2><p>Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有@Service，@Repository，@Controller等，它们都“派生”自@Component注解。我们都知道，凡是被@Component标注的类都会被Spring扫描并纳入到IOC容器中，那么由@Component派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要来通过自定义模式注解来了解@Component的“派生性”和“层次性”。</p>
<h3 id="Component-“派生性”"><a href="#Component-“派生性”" class="headerlink" title="@Component “派生性”"></a>@Component “派生性”</h3><p>新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，artifactId为autoconfig，并引入spring-boot-starter-web依赖<br>在com.example.demo下新建annotation包，然后创建一个FirstLevelService注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Service</span><br><span class="line">public @interface FirstLevelService &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解定义由@Service标注，查看@Service的源码会发现其被@Component注解标注，所以它们的层次关系为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br></pre></td></tr></table></figure>

<p>即@FirstLevelService为@Component派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：</p>
<p>在com.example.demo下新建service包，然后创建一个TestService类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@FirstLevelService</span><br><span class="line">public class TestService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在com.example.demo下新建bootstrap包，然后创建一个ServiceBootStrap类，用于测试注册TestService并从IOC容器中获取它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&quot;com.example.demo.service&quot;)</span><br><span class="line">public class ServiceBootstrap &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConfigurableApplicationContext context = new SpringApplicationBuilder(ServiceBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        TestService testService = context.getBean(&quot;testService&quot;, TestService.class);</span><br><span class="line">        System.out.println(&quot;TestService Bean: &quot; + testService);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该类的main方法，控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestService Bean: com.example.ceshi.service.TestService@5dd1c9f2</span><br></pre></td></tr></table></figure>

<h3 id="Component-“层次性”"><a href="#Component-“层次性”" class="headerlink" title="@Component “层次性”"></a>@Component “层次性”</h3><p>我们在com.example.demo.annotation路径下再创建一个SecondLevelService注解定义，该注解由上面的@FirstLevelService标注：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@FirstLevelService</span><br><span class="line">public @interface SecondLevelService &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时层次关系为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br><span class="line">            └─@SecondLevelService</span><br></pre></td></tr></table></figure>

<p>我们将TestService上的注解换成@SecondLevelService，然后再次运行ServiceBootStrap的main方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestService Bean: com.example.ceshi.service.TestService@134d26af</span><br></pre></td></tr></table></figure>
<p>可见结果也是成功的。</p>
<pre><code>这里有一点需要注意的是：@Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。</code></pre><h2 id="Enable模块驱动"><a href="#Enable模块驱动" class="headerlink" title="@Enable模块驱动"></a>@Enable模块驱动</h2><p>@Enable模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过@Enable模块驱动，我们可以开启相应的模块功能。</p>
<p>@Enable模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：</p>
<h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>Spring中，基于注解驱动的示例可以查看@EnableWebMvc源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration：<br><img src="https://i.loli.net/2019/11/04/upAFjtLqYCJhbeX.png" alt="QQ截图20190220170120.png"><br>该配置类又继承自WebMvcConfigurationSupport，里面定义了一些Bean的声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</span><br></pre></td></tr></table></figure>

<p>我们来定义一个基于注解驱动的@Enable模块驱动。<br>在com.example.demo下新建configuration包，然后创建一个HelloWorldConfiguration配置类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//@Configuration</span><br><span class="line">public class HelloWorldConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置类里定义了一个名为hello的Bean，内容为hello world。<br>在com.example.demo.annotation下创建一个EnableHelloWorld注解定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(HelloWorldConfiguration.class)</span><br><span class="line">public @interface EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该类的main方法，控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Bean: hello world</span><br></pre></td></tr></table></figure>
<p>说明我们自定义的基于注解驱动的@EnableHelloWorld是可行的。</p>
<p>注意：在HelloWorldConfiguration类不要加上@Configuration注解，否则@EnableHelloWorld注解不起作用</p>
<h3 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h3><p>除了使用上面这个方式外，我们还可以通过接口编程的方式来实现@Enable模块驱动。Spring中，基于接口编程方式的有@EnableCaching注解，查看其源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="line">public @interface EnableCaching &#123;</span><br><span class="line">    boolean proxyTargetClass() default false;</span><br><span class="line"></span><br><span class="line">    AdviceMode mode() default AdviceMode.PROXY;</span><br><span class="line"></span><br><span class="line">    int order() default 2147483647;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/shiro/Shiro%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/shiro/Shiro%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Shiro快速入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-04 08:30:18 / Modified: 20:18:26" itemprop="dateCreated datePublished" datetime="2019-11-04T08:30:18+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shiro/" itemprop="url" rel="index">
                    <span itemprop="name">shiro</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shiro快速入门"><a href="#Shiro快速入门" class="headerlink" title="Shiro快速入门"></a>Shiro快速入门</h1><hr>
<h2 id="搭建Shiro环境"><a href="#搭建Shiro环境" class="headerlink" title="搭建Shiro环境"></a>搭建Shiro环境</h2><p>引入Shiro的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>如果要和springboot项目整合，则需要引入shiro的starter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="Enable-Shiro"><a href="#Enable-Shiro" class="headerlink" title="Enable Shiro"></a>Enable Shiro</h3><p>在应用程序中启用Shiro时要了解的第一件事是，Shiro中的几乎所有内容都与称为的中央/核心组件有关SecurityManager。对于那些熟悉Java安全性的人来说，这是Shiro的SecurityManager的概念-它与并不相同java.lang.SecurityManager。<br>虽然我们将在“ 体系结构”一章中详细介绍Shiro的设计，但现在足以知道Shiro SecurityManager是应用程序Shiro环境的核心，SecurityManager每个应用程序必须存在一个。因此，我们在Tutorial应用程序中必须做的第一件事就是设置SecurityManager实例。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>尽管我们可以SecurityManager直接实例化一个类，但Shiro的SecurityManager实现具有足够的配置选项和内部组件，这使得在Java源代码中很难做到这一点- SecurityManager使用基于文本的灵活配置格式进行配置会容易得多。</p>
<p>为此，Shiro通过基于文本的INI配置提供了默认的“共母”解决方案。如今，人们已经厌倦了使用庞大的XML文件，并且INI易于阅读，易于使用并且几乎不需要依赖。稍后您还将看到，通过简单地了解对象图导航，可以有效地使用INI来配置简单的对象图，例如SecurityManager。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shiro许多配置选项</span><br><span class="line"></span><br><span class="line">Shiro的SecurityManager实现和所有支持组件都与JavaBeans兼容。这使得Shiro几乎可以使用任何配置格式进行配置，例如XML（Spring，JBoss，Guice等），YAML，JSON，Groovy Builder标记等。INI只是Shiro的“通用分母”格式，允许在没有其他选项的情况下在任何环境中进行配置。</span><br></pre></td></tr></table></figure>

<p>shiro.ini<br>因此，我们将使用INI文件SecurityManager为该简单应用程序配置Shiro 。首先，创建一个src/main/resources目录，从所在的目录开始pom.xml。然后shiro.ini在该新目录中创建一个文件，其内容如下：</p>
<p>src / main / resources / shiro.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># =============================================================================</span><br><span class="line"># Tutorial INI configuration</span><br><span class="line">#</span><br><span class="line"># Usernames/passwords are based on the classic Mel Brooks&apos; film &quot;Spaceballs&quot; :)</span><br><span class="line"># =============================================================================</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Users and their (optional) assigned roles</span><br><span class="line"># username = password, role1, role2, ..., roleN</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[users]</span><br><span class="line">root = secret, admin</span><br><span class="line">guest = guest, guest</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Roles with assigned permissions</span><br><span class="line"># roleName = perm1, perm2, ..., permN</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[roles]</span><br><span class="line">admin = *</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure>

<h4 id="引用配置"><a href="#引用配置" class="headerlink" title="引用配置"></a>引用配置</h4><p>现在已经定义了一个INI文件，我们可以SecurityManager在Tutorial应用程序类中创建实例。更改main方法以反映以下更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;My First Apache Shiro Application&quot;);</span><br><span class="line"></span><br><span class="line">    //1.</span><br><span class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line"></span><br><span class="line">    //2.</span><br><span class="line">    SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">    //3.</span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">    System.exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Shiro"><a href="#使用Shiro" class="headerlink" title="使用Shiro"></a>使用Shiro</h3><p>现在我们的SecurityManager已经设置好并且可以使用了，现在我们可以开始做我们真正关心的事情了-执行安全操作。</p>
<p>在保护我们的应用程序安全时，我们可能问自己最相关的问题是“当前用户是谁？”或“是否允许当前用户执行X”？在编写代码或设计用户界面时，通常会问这些问题：应用程序通常是基于用户案例构建的，并且您希望基于每个用户来表示（并保护）功能。因此，我们考虑应用程序安全性的最自然方法是基于当前用户。Shiro的API从根本上代表了“当前用户”的Subject概念。</p>
<p>在几乎所有环境中，您都可以通过以下调用获取当前执行的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>使用SecurityUtils.getSubject()，我们可以获得当前正在执行的Subject。一个主题仅仅是一个应用程序用户的特定安全“视图”。我们实际上想将其称为“用户”，因为那“很合理”，但我们决定反对：太多的应用程序具有已经具有自己的用户类/框架的现有API，并且我们不想与它们发生冲突。同样，在安全领域，该术语Subject实际上是公认的术语。好吧，继续…</p>
<p>getSubject()独立应用程序中的调用可能会Subject在特定于应用程序的位置中返回基于用户数据的，而在服务器环境（例如Web应用程序）中，它会获取Subject与当前线程或传入请求相关联的基于用户数据的。</p>
<p>现在您有了Subject，您可以使用它做什么？<br>如果要在用户与应用程序的当前会话期间使事情可用，则可以获取他们的会话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = currentUser.getSession();</span><br><span class="line">session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );</span><br></pre></td></tr></table></figure>
<p>这Session是Shiro特有的实例，它提供了常规HttpSession所使用的大部分功能，但具有一些额外的优点和一个很大的不同：它不需要HTTP环境！如果部署在Web应用程序内部，则默认情况下Session将HttpSession基于该应用程序。但是，在非Web环境中，例如简单的快速入门，Shiro将默认自动使用其企业会话管理。这意味着无论部署环境如何，您都可以在任何层的应用程序中使用相同的API。这就打开了一个全新的应用程序世界，因为不需要强制要求使用会话的任何应用程序使用HttpSession或EJB状态会话Bean。而且，任何客户端技术现在都可以共享会话数据。</p>
<p>因此，现在您可以获取Subject和Session。怎么样真的像检查，如果他们被允许做的事情，比如对角色和权限检查有用的东西？</p>
<p>好吧，我们只能对已知用户进行检查。我们Subject上面的实例表示当前用户，但谁是当前用户？好吧，他们是匿名的-也就是说，直到他们至少登录一次。因此，让我们这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ( !currentUser.isAuthenticated() ) &#123;</span><br><span class="line">    //collect user principals and credentials in a gui specific manner</span><br><span class="line">    //such as username/password html form, X509 certificate, OpenID, etc.</span><br><span class="line">    //We&apos;ll use the username/password example here since it is the most common.</span><br><span class="line">    //(do you know what movie this is from? ;)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    //this is all you have to do to support &apos;remember me&apos; (no config - built in!):</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而已！再简单不过了。</p>
<p>但是，如果他们的登录尝试失败了怎么办？您可以捕获各种特定的异常，这些异常可以准确地告诉您发生了什么，并允许您进行相应的处理和响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    currentUser.login( token );</span><br><span class="line">    //if no exception, that&apos;s it, we&apos;re done!</span><br><span class="line">&#125; catch ( UnknownAccountException uae ) &#123;</span><br><span class="line">    //username wasn&apos;t in the system, show them an error message?</span><br><span class="line">&#125; catch ( IncorrectCredentialsException ice ) &#123;</span><br><span class="line">    //password didn&apos;t match, try again?</span><br><span class="line">&#125; catch ( LockedAccountException lae ) &#123;</span><br><span class="line">    //account for that username is locked - can&apos;t login.  Show them a message?</span><br><span class="line">&#125;</span><br><span class="line">    ... more types exceptions to check if you want ...</span><br><span class="line">&#125; catch ( AuthenticationException ae ) &#123;</span><br><span class="line">    //unexpected condition - error?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以检查许多不同类型的异常，也可以针对自定义条件抛出自己的异常，而Shiro可能无法解决。有关更多信息，请参见AuthenticationException JavaDoc(<a href="https://shiro.apache.org/static/1.4.1/apidocs/org/apache/shiro/authc/AuthenticationException.html)。" target="_blank" rel="noopener">https://shiro.apache.org/static/1.4.1/apidocs/org/apache/shiro/authc/AuthenticationException.html)。</a></p>
<p><em>安全最佳实践是将通用的登录失败消息发送给用户，因为您不想帮助攻击者尝试闯入您的系统。</em></p>
<p>好的，现在，我们已经有一个登录用户。我们还能做什么？</p>
<p>假设他们是谁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//print their identifying principal (in this case, a username): </span><br><span class="line">log.info( &quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot; );</span><br></pre></td></tr></table></figure>

<p>我们还可以测试一下它们是否具有特定作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ( currentUser.hasRole( &quot;schwartz&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;May the Schwartz be with you!&quot; );</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info( &quot;Hello, mere mortal.&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以查看他们是否有权对某种类型的实体采取行动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ( currentUser.isPermitted( &quot;lightsaber:weild&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们可以执行功能非常强大的实例级权限检查-能够查看用户是否具有访问类型的特定实例的能力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( currentUser.isPermitted( &quot;winnebago:drive:eagle5&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You are permitted to &apos;drive&apos; the &apos;winnebago&apos; with license plate (id) &apos;eagle5&apos;.  &quot; +</span><br><span class="line">                &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, you aren&apos;t allowed to drive the &apos;eagle5&apos; winnebago!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小菜一碟吧？</p>
<p>最后，当用户使用完应用程序后，他们可以注销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout(); //removes all identifying information and invalidates their session too.</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/shiro/Shiro%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/shiro/Shiro%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">Shiro中的术语</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-04 08:08:51 / Modified: 08:20:46" itemprop="dateCreated datePublished" datetime="2019-11-04T08:08:51+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shiro/" itemprop="url" rel="index">
                    <span itemprop="name">shiro</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shiro中的术语"><a href="#Shiro中的术语" class="headerlink" title="Shiro中的术语"></a>Shiro中的术语</h1><hr>
<h2 id="Authentication-身份"><a href="#Authentication-身份" class="headerlink" title="Authentication(身份)"></a>Authentication(身份)</h2><p>验证身份验证是验证主体身份的过程-本质上证明某人确实是他们所说的真实身份。身份验证尝试成功后，应用程序可以相信可以保证主题是应用程序期望的对象。</p>
<h2 id="Authorizatio-授权"><a href="#Authorizatio-授权" class="headerlink" title="Authorizatio(授权)"></a>Authorizatio(授权)</h2><p>授权（也称为访问控制）是确定是否允许用户/主题做某事的过程。通常，通过检查并解释主题的角色和权限（请参见下文），然后允许或拒绝对请求的资源或功能的访问来完成此操作。</p>
<h2 id="Cipher-密码"><a href="#Cipher-密码" class="headerlink" title="Cipher(密码)"></a>Cipher(密码)</h2><p>密码是一种用于执行加密或解密的算法。该算法通常依赖于一条称为密钥的信息。而且加密因密钥而异，因此如果没有密钥，解密将非常困难。<br>密码有不同的变化。块密码器处理通常具有固定大小的符号块，而流密码器处理连续的符号流。对称密码使用相同的密钥进行加密和解密，而非对称密码使用不同的密钥。而且，如果不能从另一个密钥中获得非对称密码中的一个密钥，则可以公开共享一个密钥，从而创建公共/私有密钥对。</p>
<h2 id="Credential-凭证"><a href="#Credential-凭证" class="headerlink" title="Credential(凭证)"></a>Credential(凭证)</h2><p>凭证是一块用于验证用户/主题的身份的信息。在身份验证尝试期间，将一个（或多个）凭据与主体一起提交，以验证提交凭据的用户/主题实际上是关联的用户。凭证通常是只有特定用户/主体才能知道的非常机密的事物，例如密码或PGP密钥或生物特征或类似机制。<br>这个想法是，对于一个校长，只有一个人会知道与该校长“配对”的正确凭证。如果当前用户/主题提供的正确凭据与系统中存储的凭据相匹配，则系统可以假定并相信当前用户/主题确实是他们所说的真实身份。信任程度随着更安全的凭据类型（例如，生物特征签名&gt;密码）而增加。</p>
<h2 id="Permission-权限"><a href="#Permission-权限" class="headerlink" title="Permission(权限)"></a>Permission(权限)</h2><p>至少按照Shiro的解释，权限是一种描述应用程序中原始功能的语句，仅此而已。权限是安全策略中最低级别的构造。它们仅定义应用程序可以执行的“操作”。他们没有描述“谁”能够执行这些动作。许可只是行为的陈述，仅此而已。<br>权限的一些示例：</p>
<ul>
<li>开启档案</li>
<li>查看“ /用户/列表”网页</li>
<li>列印文件</li>
<li>删除“ jsmith”用户</li>
</ul>
<h2 id="Principal"><a href="#Principal" class="headerlink" title="Principal"></a>Principal</h2><h2 id="Relm"><a href="#Relm" class="headerlink" title="Relm"></a>Relm</h2><h2 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h2><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h2 id="Suject"><a href="#Suject" class="headerlink" title="Suject"></a>Suject</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/04/shiro/Shiro%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/04/shiro/Shiro%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Shiro简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-04 08:00:58 / Modified: 11:08:19" itemprop="dateCreated datePublished" datetime="2019-11-04T08:00:58+08:00">2019-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shiro/" itemprop="url" rel="index">
                    <span itemprop="name">shiro</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h1><hr>
<h2 id="什么是Apache-Shiro"><a href="#什么是Apache-Shiro" class="headerlink" title="什么是Apache Shiro"></a>什么是Apache Shiro</h2><p>Apache Shiro是一个功能强大且灵活的开源安全框架，可以干净地处理身份验证，授权，企业会话管理和加密。</p>
<p>Apache Shiro的首要目标是易于使用和理解。安全有时可能非常复杂，甚至会很痛苦，但这不是必须的。框架应尽可能掩盖复杂性，并公开简洁直观的API，以简化开发人员确保其应用程序安全的工作。<br>您可以使用Apache Shiro进行以下操作：</p>
<ul>
<li>验证用户身份以验证其身份</li>
<li>对用户执行访问控制，例如：<ul>
<li>确定是否为用户分配了特定的安全角色</li>
<li>确定是否允许用户做某事</li>
</ul>
</li>
<li>即使在没有Web或EJB容器的情况下，也可以在任何环境中使用Session API。</li>
<li>在身份验证，访问控制或会话的生存期内对事件做出反应。</li>
<li>汇总1个或更多用户安全数据的数据源，并将其全部显示为单个复合用户“视图”。</li>
<li>启用单点登录（SSO）功能</li>
<li>启用“记住我”服务以进行用户关联，而无需登录<br>等等-所有这些都集成到一个易于使用的统一API中。<br>Shiro尝试在所有应用程序环境中实现这些目标-从最简单的命令行应用程序到最大的企业应用程序，而不必强加对其他第三方框架，容器或应用程序服务器的依赖。当然，该项目旨在尽可能地集成到这些环境中，但是可以在任何环境中直接使用它。</li>
</ul>
<h2 id="Apache-Shiro功能"><a href="#Apache-Shiro功能" class="headerlink" title="Apache Shiro功能"></a>Apache Shiro功能</h2><p>Apache Shiro是具有许多功能的全面的应用程序安全框架。下图显示了Shiro集中精力的地方，本参考手册的组织方式也类似：<br><img src="https://i.loli.net/2019/11/04/7TkNwl2PFvadBRI.png" alt="ShiroFeatures.png"><br>Shiro以Shiro开发团队所谓的“应用程序安全性的四个基石”为目标-身份验证，授权，会话管理和密码学：</p>
<ul>
<li><p>身份验证：有时称为“登录”，这是证明用户是他们所说的身份的行为。</p>
</li>
<li><p>授权：访问控制的过程，即确定“谁”有权访问“什么”。</p>
</li>
<li><p>会话管理：即使在非Web或EJB应用程序中，也可以管理用户特定的会话。</p>
</li>
<li><p>密码术：使用密码算法保持数据安全，同时仍然易于使用。</p>
</li>
</ul>
<p>在不同的应用程序环境中，还具有其他功能来支持和加强这些问题，尤其是：</p>
<ul>
<li>Web支持：Shiro的Web支持API可帮助轻松保护Web应用程序的安全。</li>
<li>缓存：缓存是Apache Shiro API的第一层公民，可确保安全操作保持快速有效。</li>
<li>并发性：Apache Shiro的并发功能支持多线程应用程序。</li>
<li>测试：测试支持可以帮助您编写单元测试和集成测试，并确保您的代码将按预期进行保护。</li>
<li>“运行方式”：一种功能，允许用户采用其他用户的身份（如果允许），有时在管理方案中很有用。</li>
<li>“记住我”：在整个会话中记住用户的身份，因此他们只需要在必要时登录。</li>
</ul>
<p>shiro不会去维护用户，维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给shiro<br><img src="https://i.loli.net/2019/11/04/CjdnexzlNaWQByI.png" alt="shiro1.PNG"><br>直接与代码交互的对象是Subject，也就是说Shiro对外API的核心是Subject<br>Subject: 主体，代表当前“用户”，所有的Subject都绑定到SecurityManager，都委托给SecurityManager, SUbject相当于门面，而SecurityManager才是实际的执行者；<br>SecurityManager：我是安全管理器，所有有安全相关的操作，都会交给我来处理，我管理着所有的Subject，我是核心，我负责与其他组件进行交互，你也可以你把我比作springmvc里面的前端控制器，<br>Realm: 我叫域，Shiro要从我这里获取安全数据（用户，角色，权限），也就是说SecurityManager要验证身份，需要从我这里获取相应用户的身份，也需要从我这里获取权限，可以把我 看作安全数据源；</p>
<p>从上面也可以看出，Shiro不提供维护用户和权限，而是用过Realm让开发人员自己注入；<br><img src="https://i.loli.net/2019/11/04/KOv4hQXotmpJ9DY.png" alt="shiro2.PNG"><br>Subject: 主体<br>SecurityManager:心脏<br>Authentication:认证器<br>Authorizer: 授权器<br>Realm:可以有一个或者多个，安全的实体数据源<br>SessionManager: Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境<br>SessionDao:<br>CacheManager:缓存控制器 ，放到 缓存中可以提高访问性能；<br>Cryptography: 密码模块；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/02/Mysql/MySql%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/Mysql/MySql%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A/" class="post-title-link" itemprop="url">Mysql中的一对多和多对多</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-02 23:26:29 / Modified: 23:46:32" itemprop="dateCreated datePublished" datetime="2019-11-02T23:26:29+08:00">2019-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mysql中的一对多和多对多"><a href="#Mysql中的一对多和多对多" class="headerlink" title="Mysql中的一对多和多对多"></a>Mysql中的一对多和多对多</h1><hr>
<h2 id="关联映射：一对多-多对一"><a href="#关联映射：一对多-多对一" class="headerlink" title="关联映射：一对多/多对一"></a>关联映射：一对多/多对一</h2><p>存在最普遍的映射关系，简单来讲就如球员与球队的关系；<br>一对多：从球队角度来说一个球队拥有多个球员 即为一对多<br>多对一：从球员角度来说多个球员属于一个球队 即为多对一数据表间一对多关系如下图：<br><img src="https://i.loli.net/2019/11/02/7UbepvPs6gDkLtd.jpg" alt="15234704-7cacb7b37f794c0e91f92cae94f03753.jpg"></p>
<p>sql语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sockerteam(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">team_name VARCHAR(25)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE sockerplayer</span><br><span class="line">(</span><br><span class="line">id INT PRIMARY KEY auto_increment,</span><br><span class="line">`name` VARCHAR(25) NOT NULL, </span><br><span class="line">teamId INT,</span><br><span class="line">CONSTRAINT team_player FOREIGN KEY (teamId) REFERENCES sockerteam(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="关联映射：多对多"><a href="#关联映射：多对多" class="headerlink" title="关联映射：多对多"></a>关联映射：多对多</h2><p>多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。<br>数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。<br>数据表间多对多关系如下图：<br><img src="https://i.loli.net/2019/11/02/cDXvu3BKI5FVonM.jpg" alt="15235342-153ef6a865fb47f391eb66f443e21370.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/02/Mysql/Mysql%E5%87%A0%E5%A4%A7%E7%BA%A6%E6%9D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/Mysql/Mysql%E5%87%A0%E5%A4%A7%E7%BA%A6%E6%9D%9F/" class="post-title-link" itemprop="url">Mysql几大约束</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 22:50:29" itemprop="dateCreated datePublished" datetime="2019-11-02T22:50:29+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-08 14:39:19" itemprop="dateModified" datetime="2019-11-08T14:39:19+08:00">2019-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mysql几大约束"><a href="#Mysql几大约束" class="headerlink" title="Mysql几大约束"></a>Mysql几大约束</h1><hr>
<h2 id="1、主键约束"><a href="#1、主键约束" class="headerlink" title="1、主键约束"></a>1、主键约束</h2><p>&emsp;&emsp;Mysql单个字段设为主键很简单，怎么设置两个及以上字段为主键呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table test </span><br><span class="line">( </span><br><span class="line">   name varchar(19), </span><br><span class="line">   id number, </span><br><span class="line">   value varchar(10), </span><br><span class="line">   primary key (name,id) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样设置的主键称为复合主键，也就由一个以上的字段构成的主键。</p>
<h2 id="2、外键约束"><a href="#2、外键约束" class="headerlink" title="2、外键约束"></a>2、外键约束</h2><p>&emsp;&emsp;外键用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以是空值，若不为空值，则每个外键值必须等于另一个表中主键的某个值。<br>&emsp;&emsp;外键：外键的主要作用是保证数据引用的完整性，定义外键后，不允许删除在另一个表中的具有关联关系的行。</p>
<ul>
<li>主表(父表)：相关联字段中主键所在的表</li>
<li>从表(子表)：相关联字段中外键所在的表<br>语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建外键：</span><br><span class="line">[constraint &lt;外键名&gt;] foreign key 字段名1[,字段名2,...] references &lt;主表名&gt; 主键列1【，主键列2,...]</span><br><span class="line"></span><br><span class="line">删除外键</span><br><span class="line">alter table tableName drop foreign key foreignKeyName;</span><br></pre></td></tr></table></figure>
示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sockerteam(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">team_name VARCHAR(25)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE sockerplayer</span><br><span class="line">(</span><br><span class="line">id INT PRIMARY KEY auto_increment,</span><br><span class="line">`name` VARCHAR(25) NOT NULL, </span><br><span class="line">teamId INT,</span><br><span class="line">CONSTRAINT team_player FOREIGN KEY (teamId) REFERENCES sockerteam(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3、非空约束"><a href="#3、非空约束" class="headerlink" title="3、非空约束"></a>3、非空约束</h2><h2 id="4、唯一性约束"><a href="#4、唯一性约束" class="headerlink" title="4、唯一性约束"></a>4、唯一性约束</h2><p>&emsp;&emsp;唯一性约束(Unique Constraint)要求该列唯一，允许为空，但只能出现一个空值。<br>语法规则如下：<br>1、在定义完列之后直接指定唯一约束，语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 数据类型 UNIQUE</span><br></pre></td></tr></table></figure>

<p>2、在定义完所有列之后指定唯一约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[constraint &lt;约束名&gt;] UNIQUE (&lt;字段名&gt;)</span><br></pre></td></tr></table></figure>
<h2 id="5、默认约束"><a href="#5、默认约束" class="headerlink" title="5、默认约束"></a>5、默认约束</h2><p>默认约束指定某列的默认值。<br>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名数据类型 default 默认值</span><br></pre></td></tr></table></figure>

<h2 id="6、设置表的属性值自动增加"><a href="#6、设置表的属性值自动增加" class="headerlink" title="6、设置表的属性值自动增加"></a>6、设置表的属性值自动增加</h2><p>默认的，在Mysql中AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分。<br>语法规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 数据类型 AUTO_INCREMENT</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/02/Activiti/Activiti%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/Activiti/Activiti%20API/" class="post-title-link" itemprop="url">Activiti API</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 21:12:45" itemprop="dateCreated datePublished" datetime="2019-11-02T21:12:45+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-04 23:53:36" itemprop="dateModified" datetime="2019-11-04T23:53:36+08:00">2019-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Activiti/" itemprop="url" rel="index">
                    <span itemprop="name">Activiti</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activiti-API"><a href="#Activiti-API" class="headerlink" title="Activiti API"></a>Activiti API</h1><hr>
<p>ProcessEngine API是与Activiti交互的最常见方式。中心起点是ProcessEngine，可以按照配置部分中所述的多种方式创建 。从ProcessEngine，您可以获取包含工作流/ BPM方法的各种服务。ProcessEngine和服务对象是线程安全的。因此，您可以为整个服务器保留对其中之一的引用。<br><img src="https://i.loli.net/2019/11/02/XmiH2ZJc5v3a8Sh.png" alt="api.services.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line"></span><br><span class="line">RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">TaskService taskService = processEngine.getTaskService();</span><br><span class="line">ManagementService managementService = processEngine.getManagementService();</span><br><span class="line">IdentityService identityService = processEngine.getIdentityService();</span><br><span class="line">HistoryService historyService = processEngine.getHistoryService();</span><br><span class="line">FormService formService = processEngine.getFormService();</span><br><span class="line">DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService();</span><br></pre></td></tr></table></figure>

<p>ProcessEngines.getDefaultProcessEngine()会在首次调用时初始化并构建一个流程引擎，此后始终返回相同的流程引擎。可以使用ProcessEngines.init() 和正确创建和关闭所有流程引擎ProcessEngines.destroy()。</p>
<p>ProcessEngines类将扫描所有activiti.cfg.xml和activiti-context.xml文件。对于所有activiti.cfg.xml文件，将以典型的Activiti方式构建流程引擎：ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()。对于所有activiti-context.xml文件，将以Spring方式构建流程引擎：首先创建Spring应用程序上下文，然后从该应用程序上下文中获取流程引擎。</p>
<p>所有服务都是无状态的。这意味着您可以轻松地在群集中的多个节点上运行Activiti，每个节点都访问同一数据库，而不必担心哪台计算机实际执行了先前的调用。无论在何处执行，对任何服务的任何调用都是幂等的。</p>
<h2 id="各个节点的Service"><a href="#各个节点的Service" class="headerlink" title="各个节点的Service"></a>各个节点的Service</h2><h3 id="RepositoryService"><a href="#RepositoryService" class="headerlink" title="RepositoryService"></a>RepositoryService</h3><p>当使用Activiti引擎时，RepositoryService可能是第一个需要的服务。这项服务提供运营管理和操纵deployments和process definitions。此处无需赘述，流程定义是BPMN 2.0流程的Java对应项。它代表了流程中每个步骤的结构和行为。A deployment是Activiti引擎中包装的单位。一个部署可以包含多个BPMN 2.0 xml文件和任何其他资源。一个部署中包含的内容的选择取决于开发人员。它的范围从单个流程BPMN 2.0 xml文件到整个流程包和相关资源（例如，部署hr-processes）可能包含与HR流程的一切）。在RepositoryService允许deploy这样的包。部署部署意味着将其上载到引擎，在这里将检查并解析所有进程，然后再将它们存储在数据库中。从那时起，系统便知道该部署，并且现在可以启动该部署中包括的任何过程。</p>
<p>此外，这项服务还可以</p>
<ul>
<li><p>查询引擎已知的部署和流程定义。</p>
</li>
<li><p>挂起并激活整个部署或特定过程定义。挂起表示无法对其进行进一步的操作，而激活是相反的操作。</p>
</li>
<li><p>检索各种资源，例如部署中包含的文件或引擎自动生成的流程图。</p>
</li>
<li><p>检索流程定义的POJO版本，该版本可用于使用Java而不是xml自省流程。</p>
</li>
</ul>
<h3 id="RuntimeService"><a href="#RuntimeService" class="headerlink" title="RuntimeService"></a>RuntimeService</h3><p>它处理启动流程定义的新流程实例。如上所述，a process definition定义了过程中不同步骤的结构和行为。流程实例是这种流程定义的一种执行。对于每个流程定义，通常会同时运行许多实例。这RuntimeService也是用于检索和存储的服务process variables。这是特定于给定流程实例的数据，并且可以由流程中的各种构造使用（例如，专用网关通常使用流程变量来确定选择哪个路径来继续该流程）。</p>
<h2 id="使用Activiti服务"><a href="#使用Activiti服务" class="headerlink" title="使用Activiti服务"></a>使用Activiti服务</h2><p>如上所述，与Activiti引擎进行交互的方式是通过org.activiti.engine.ProcessEngine类实例公开的服务。以下代码段假定您具有有效的Activiti环境，即您可以访问有效的org.activiti.engine.ProcessEngine。如果您只想尝试下面的代码，则可以下载或克隆Activiti单元测试模板，将其导入IDE中，然后将testUserguideCode()方法添加到org.activiti.MyUnitTest单元测试中。</p>
<p>这个小教程的最终目标是要有一个能正常工作的业务流程，该流程模仿公司中一个简单的假期请求流程：<br><img src="https://i.loli.net/2019/11/02/zswSxg3GMAHL5Iy.png" alt="api.vacationRequest.png"></p>
<h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><p>与静态数据相关的所有内容（例如流程定义）都可以通过RepositoryService访问。从概念上讲，每个此类静态数据都是Activiti引擎存储库的内容。</p>
<p>为了使Activiti引擎知道此过程，我们必须首先对其进行部署。部署意味着引擎将BPMN 2.0 xml解析为可执行文件，并为部署中包括的每个流程定义添加新的数据库记录。这样，当引擎重新启动时，它仍然会知道所有已部署的进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">repositoryService.createDeployment()</span><br><span class="line">  .addClasspathResource(&quot;org/activiti/test/VacationRequest.bpmn20.xml&quot;)</span><br><span class="line">  .deploy();</span><br><span class="line"></span><br><span class="line">Log.info(&quot;Number of process definitions: &quot; + repositoryService.createProcessDefinitionQuery().count());</span><br></pre></td></tr></table></figure>

<h3 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h3><p>将流程定义部署到Activiti引擎后，我们可以从中启动新流程实例。对于每个流程定义，通常都有许多流程实例。流程定义是蓝图，而流程实例是其运行时执行。<br>与进程的运行时状态相关的所有内容都可以在RuntimeService中找到。有多种启动新流程实例的方法。在以下代码段中，我们使用在流程定义xml中定义的键来启动流程实例。我们还在流程实例启动时提供了一些流程变量，因为第一个用户任务的描述将在其表达式中使用它们。通常使用过程变量，因为它们为特定过程定义的过程实例赋予了含义。通常，流程变量使流程实例彼此不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//定义流程变量</span><br><span class="line">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">variables.put(&quot;employeeName&quot;, &quot;Kermit&quot;);</span><br><span class="line">variables.put(&quot;numberOfDays&quot;, new Integer(4));</span><br><span class="line">variables.put(&quot;vacationMotivation&quot;, &quot;I&apos;m really tired!&quot;);</span><br><span class="line"></span><br><span class="line">RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;vacationRequest&quot;, variables);</span><br><span class="line"></span><br><span class="line">// Verify that we started a new process instance</span><br><span class="line">Log.info(&quot;Number of process instances: &quot; + runtimeService.createProcessInstanceQuery().count());</span><br></pre></td></tr></table></figure>

<h3 id="完成任务"><a href="#完成任务" class="headerlink" title="完成任务"></a>完成任务</h3><p>该过程开始时，第一步将是用户任务。这是系统用户必须执行的步骤。通常，此类用户将拥有一个任务收件箱，其中列出了该用户需要完成的所有任务。以下代码段显示了如何执行这种查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Fetch all tasks for the management group</span><br><span class="line">TaskService taskService = processEngine.getTaskService();</span><br><span class="line">List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&quot;management&quot;).list();</span><br><span class="line">for (Task task : tasks) &#123;</span><br><span class="line">  Log.info(&quot;Task available: &quot; + task.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要继续该流程实例，我们需要完成此任务。对于Activiti引擎，这意味着您需要complete执行任务。以下片段显示了如何完成此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task task = tasks.get(0);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; taskVariables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">taskVariables.put(&quot;vacationApproved&quot;, &quot;false&quot;);</span><br><span class="line">taskVariables.put(&quot;managerMotivation&quot;, &quot;We have a tight deadline!&quot;);</span><br><span class="line">taskService.complete(task.getId(), taskVariables);</span><br></pre></td></tr></table></figure>

<p>现在，流程实例将继续进行下一步。在此示例中，下一步允许员工填写可调整其原始休假请求的表格。员工可以重新提交休假请求，这将导致流程循环回到启动任务。</p>
<h3 id="暂停或激活流程"><a href="#暂停或激活流程" class="headerlink" title="暂停或激活流程"></a>暂停或激活流程</h3><p>可以暂停流程定义。流程定义被挂起时，无法创建新的流程实例（将引发异常）。可以通过以下方式暂停流程定义RepositoryService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositoryService.suspendProcessDefinitionByKey(&quot;vacationRequest&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">  runtimeService.startProcessInstanceByKey(&quot;vacationRequest&quot;);</span><br><span class="line">&#125; catch (ActivitiException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要重新激活流程定义，只需调用其中一种repositoryService.activateProcessDefinitionXXX方法。<br>也可以挂起流程实例。暂停后，该过程将无法继续执行（例如，完成任务会引发异常），并且不会执行任何作业（例如计时器）。可以通过调用runtimeService.suspendProcessInstance方法来挂起流程实例。通过调用runtimeService.activateProcessInstanceXXX方法来再次激活流程实例。</p>
<h2 id="查询API"><a href="#查询API" class="headerlink" title="查询API"></a>查询API</h2><p>…待写</p>
<h2 id="流程变量"><a href="#流程变量" class="headerlink" title="流程变量"></a>流程变量</h2><p>=====待写</p>
<h2 id="瞬态变量"><a href="#瞬态变量" class="headerlink" title="瞬态变量"></a>瞬态变量</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lancersaber.github.io/2019/11/02/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancersaber">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancersaber">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">对象序列化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 20:09:41" itemprop="dateCreated datePublished" datetime="2019-11-02T20:09:41+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-04 21:19:13" itemprop="dateModified" datetime="2019-11-04T21:19:13+08:00">2019-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><hr>
<h2 id="序列化是什么？"><a href="#序列化是什么？" class="headerlink" title="序列化是什么？"></a>序列化是什么？</h2><p>&emsp;&emsp;当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。尽管这么做肯定是有意义的，但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。如果能够将一个对象声明为是“持久化”的，并为我们处理掉所有细节，那将会显得十分方便。<br>&emsp;&emsp;Java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节完全恢复为原来的对象。<br>对象序列化概念的加入是为了支持两种主要特性：</p>
<ul>
<li>Java的远程方法调用</li>
<li>保存设计阶段的Bean的状态信息<br>只要对象实现了Serializable接口(标记接口，不包括任何方法)，对象的序列化处理就会非常简单。</li>
</ul>
<h2 id="序列化的过程"><a href="#序列化的过程" class="headerlink" title="序列化的过程"></a>序列化的过程</h2><p>要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需要调用writeObject()即可将对象序列化，并将其发送给ObjectStream(对象化序列是基于字节的，因要使用InputStream和OutputStream继承层次结构)。要反向进行该过程(即将一个序列还原为一个对象)，需要将一个InputStream封装在ObjectinputStream内，然后调用readObjectt()。和往常一样，我们最后获得的是一个引用，它指向一个向上转型的Object，所以必须向下转型才能直接设置它们。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package io;//: io/Worm.java</span><br><span class="line">// Demonstrates object serialization.</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import static net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line">class Data implements Serializable &#123;</span><br><span class="line">  private int n;</span><br><span class="line">  public Data(int n) &#123; this.n = n; &#125;</span><br><span class="line">  public String toString() &#123; return Integer.toString(n); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Worm implements Serializable &#123;</span><br><span class="line">  private static Random rand = new Random(47);</span><br><span class="line">  private Data[] d = &#123;</span><br><span class="line">    new Data(rand.nextInt(10)),</span><br><span class="line">    new Data(rand.nextInt(10)),</span><br><span class="line">    new Data(rand.nextInt(10))</span><br><span class="line">  &#125;;</span><br><span class="line">  private Worm next;</span><br><span class="line">  private char c;</span><br><span class="line">  // Value of i == number of segments</span><br><span class="line">  public Worm(int i, char x) &#123;</span><br><span class="line">    print(&quot;Worm constructor: &quot; + i);</span><br><span class="line">    c = x;</span><br><span class="line">    if(--i &gt; 0)</span><br><span class="line">      next = new Worm(i, (char)(x + 1));</span><br><span class="line">  &#125;</span><br><span class="line">  public Worm() &#123;</span><br><span class="line">    print(&quot;Default constructor&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    StringBuilder result = new StringBuilder(&quot;:&quot;);</span><br><span class="line">    result.append(c);</span><br><span class="line">    result.append(&quot;(&quot;);</span><br><span class="line">    for(Data dat : d)</span><br><span class="line">      result.append(dat);</span><br><span class="line">    result.append(&quot;)&quot;);</span><br><span class="line">    if(next != null)</span><br><span class="line">      result.append(next);</span><br><span class="line">    return result.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  throws ClassNotFoundException, IOException &#123;</span><br><span class="line">    Worm w = new Worm(6, &apos;a&apos;);</span><br><span class="line">    print(&quot;w = &quot; + w);</span><br><span class="line">    ObjectOutputStream out = new ObjectOutputStream(</span><br><span class="line">      new FileOutputStream(&quot;worm.out&quot;));</span><br><span class="line">    out.writeObject(&quot;Worm storage\n&quot;);</span><br><span class="line">    out.writeObject(w);</span><br><span class="line">    out.close(); // Also flushes output</span><br><span class="line">    ObjectInputStream in = new ObjectInputStream(</span><br><span class="line">      new FileInputStream(&quot;worm.out&quot;));</span><br><span class="line">    String s = (String)in.readObject();</span><br><span class="line">    Worm w2 = (Worm)in.readObject();</span><br><span class="line">    print(s + &quot;w2 = &quot; + w2);</span><br><span class="line">    ByteArrayOutputStream bout =</span><br><span class="line">      new ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream out2 = new ObjectOutputStream(bout);</span><br><span class="line">    out2.writeObject(&quot;Worm storage\n&quot;);</span><br><span class="line">    out2.writeObject(w);</span><br><span class="line">    out2.flush();</span><br><span class="line">    ObjectInputStream in2 = new ObjectInputStream(</span><br><span class="line">      new ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">    s = (String)in2.readObject();</span><br><span class="line">    Worm w3 = (Worm)in2.readObject();</span><br><span class="line">    print(s + &quot;w3 = &quot; + w3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">Worm constructor: 6</span><br><span class="line">Worm constructor: 5</span><br><span class="line">Worm constructor: 4</span><br><span class="line">Worm constructor: 3</span><br><span class="line">Worm constructor: 2</span><br><span class="line">Worm constructor: 1</span><br><span class="line">w = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br><span class="line">Worm storage</span><br><span class="line">w2 = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br><span class="line">Worm storage</span><br><span class="line">w3 = :a(853):b(119):c(802):d(788):e(199):f(881)</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>

<h2 id="序列化中serialVersionUID作用"><a href="#序列化中serialVersionUID作用" class="headerlink" title="序列化中serialVersionUID作用"></a>序列化中serialVersionUID作用</h2><p>serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p>
<p>serialVersionUID有两种显示的生成方式：<br>一是默认的1L，比如：private static final long serialVersionUID = 1L;<br>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：<br>private static final  long   serialVersionUID = xxxxL;</p>
<p>当一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供相应的提醒。面对这种情况，我们只需要在Eclipse中点击类中warning图标一下，Eclipse就会      自动给定两种生成的方式。如果不想定义，在Eclipse的设置中也可以把它关掉的，设置如下：<br>Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt; Potential programming problems<br>将Serializable class without serialVersionUID的warning改成ignore即可。</p>
<p>当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。</p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。</p>
<h2 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h2><p>&emsp;&emsp;将一个对象从它的序列化状态中恢复出来，必须保证Java虚拟机能找到相关的.class文件</p>
<h2 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h2><p>&emsp;&emsp;默认的序列化机制并不难操作。然而，如果有特殊的需要那又该怎么办呢?</p>
<h2 id="transient-瞬时-关键字"><a href="#transient-瞬时-关键字" class="headerlink" title="transient(瞬时)关键字"></a>transient(瞬时)关键字</h2><p>&emsp;&emsp;当我们对序列化进行控制时，可能某个字段字对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息(如密码)。然而，如果我们操作是一个Serializable对象，那么所有的序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个字段地关闭序列化，它的意思是“不用麻烦你保存或恢复数据–我自己处理”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Lancersaber"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Lancersaber</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lancersaber</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/muse.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
